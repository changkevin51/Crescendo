<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Staff with Notes</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="mainstyles.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
</head>
<body>
  <main>
    <h1>Crescendo</h1>

    <div class="score-display">
      <span>Correct: <span id="correct-count">0</span></span>
      <span>Missed: <span id="missed-count">0</span></span>
      <span>Wrong: <span id="wrong-count">0</span></span>
    </div>

    <div class="unified-controls">
      <div class="detection-info">
        <div class="detected-note-display">
          <span class="label">Current Note:</span>
          <span id="current-detected-note">-</span>
        </div>
        <div class="detected-frequency-display">
          <span class="label">Frequency:</span>
          <span id="current-detected-frequency">- Hz</span>
        </div>
        <div class="accuracy-display">
          <span class="label">Accuracy:</span>
          <span id="live-accuracy">0.0%</span>
        </div>
        <div class="checkbox-control">
          <input type="checkbox" id="metronome-checkbox">
          <label for="metronome-checkbox">Metronome</label>
        </div>
      </div>
      
      <div class="game-controls">
        <button id="pause-btn" class="control-btn">Pause</button>
        <input type="file" id="music-file-upload" accept=".xml">
        <button id="end-game-btn" class="control-btn end-game">End Game & Analyze</button>
        <div class="tempo-control">
          <label for="tempo-slider">Tempo:</label>
          <input type="range" id="tempo-slider" min="0.5" max="3" step="0.1" value="1">
          <span id="tempo-value">1.0x</span>
        </div>
        <div class="note-label-toggle">
          <label for="note-labels-checkbox">Note Labels:</label>
          <input type="checkbox" id="note-labels-checkbox" checked>
        </div>
      </div>
    </div>

    <div id="osmd-container">
      <div class="judgment-line"></div>
    </div>

  </main>
  <style>
    #osmd-container {
      width: 100%;
      height: auto;
      overflow-x: hidden;
      border: 1px solid #ccc;
      padding: 10px;
      white-space: nowrap;
      position: relative;
    }

    .scrolling-music {
      animation: scrollLeft 60s linear;
    }

    @keyframes scrollLeft {
      from { transform: translateX(0); }
      to { transform: translateX(-80%); }
    }

    .judgment-line {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 100px;
      width: 3px;
      background: red;
      z-index: 10;
      pointer-events: none;
    }


  </style>
  <script src="https://unpkg.com/meyda@5.6.3/dist/web/meyda.min.js"></script>
  <script src="pitch-detector.js"></script>
  <script src="note_statistics.js"></script>
  <script src="cohere-analytics.js"></script>
  <script src="engine.js"></script>
  <script>
    // Game state variables - removed duplicate declarations that exist in engine.js
    let animationDuration = 60; // seconds
    
    // Note detection constants - using engine.js values for better accuracy
    const JUDGMENT_LINE_X = 100; // pixels from left where notes are judged
    const JUDGMENT_TOLERANCE = 50; // pixels tolerance for note judgment
    // Use constants from engine.js - don't redeclare them
    // const MIN_CONFIDENCE_FOR_SAMPLE, NOTE_CHANGE_THRESHOLD, etc. are in engine.js
    
    // Note detection state - use globals from engine.js
    // lastDetectedNote, lastDetectionTime, noteDetectionHistory are in engine.js
    
    const osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("osmd-container", {
      autoResize: false,
      drawingParameters: "compacttight" // or "default"
    });

    async function renderMusicXML(file_path) {
      // Load your MusicXML file (must be served over HTTP)
      await osmd.load(file_path); // Make sure this file is in the same folder

      // Force all music to be in a single horizontal line
      osmd.EngravingRules.PageWidth = 5000; // Big enough to fit the whole piece
      osmd.EngravingRules.RenderSingleHorizontalStaffline = true;

      osmd.render();
      
      // Re-add judgment line after rendering (since osmd.render() replaces container content)
      addJudgmentLine();
      
      // Start scrolling after rendering
      startScrolling();
    }

    function addJudgmentLine() {
      // Remove existing judgment line if any
      const existingLine = document.querySelector('.judgment-line');
      if (existingLine) {
        existingLine.remove();
      }
      
      // Create new judgment line
      const judgmentLine = document.createElement('div');
      judgmentLine.className = 'judgment-line';
      
      // Add it to the container
      const container = document.getElementById('osmd-container');
      container.appendChild(judgmentLine);
    }

    function startScrolling() {
      const musicSheet = document.querySelector('#osmd-container svg');
      if (musicSheet) {
        musicSheet.classList.add('scrolling-music');
        // Start the note recognition game
        startNoteRecognitionGame();
      }
    }

    function pauseScrolling() {
      const musicSheet = document.querySelector('#osmd-container svg');
      if (musicSheet) {
        musicSheet.style.animationPlayState = 'paused';
        isPaused = true;
        pausedTime = Date.now();
      }
    }

    function resumeScrolling() {
      const musicSheet = document.querySelector('#osmd-container svg');
      if (musicSheet) {
        musicSheet.style.animationPlayState = 'running';
        if (isPaused) {
          totalPausedTime += Date.now() - pausedTime;
          isPaused = false;
        }
      }
    }

    function setScrollSpeed(speedMultiplier) {
      const musicSheet = document.querySelector('#osmd-container svg');
      if (musicSheet) {
        const baseDuration = 60; // seconds
        const newDuration = baseDuration / speedMultiplier;
        musicSheet.style.animationDuration = `${newDuration}s`;
        tempoMultiplier = speedMultiplier;
        animationDuration = newDuration;
      }
    }

    // Note recognition system functions
    async function initializeNoteRecognition() {
      try {
        // Use global pitchDetector from engine.js if available
        if (typeof window.pitchDetector === 'undefined') {
          window.pitchDetector = new PitchDetector();
          await window.pitchDetector.initialize();
          window.pitchDetector.start();
        }
        console.log('Pitch detector initialized successfully');
      } catch (error) {
        console.error('Failed to initialize pitch detector:', error);
        document.getElementById('current-detected-note').textContent = 'Microphone access required';
      }
    }

    function extractNotesFromSVG() {
      const svg = document.querySelector('#osmd-container svg');
      if (!svg) return [];

      const notes = [];
      
      // Try multiple selectors to find note elements in OpenSheetMusicDisplay
      const possibleSelectors = [
        'g[class*="vf-notehead"]',
        'g[class*="notehead"]', 
        'ellipse[class*="notehead"]',
        'circle[class*="notehead"]',
        'path[class*="notehead"]',
        'g[class*="note"]',
        'ellipse',
        'circle'
      ];
      
      let noteElements = [];
      for (const selector of possibleSelectors) {
        noteElements = svg.querySelectorAll(selector);
        if (noteElements.length > 0) {
          console.log(`Found ${noteElements.length} notes using selector: ${selector}`);
          break;
        }
      }
      
      // If still no notes found, try to find any circular/elliptical shapes that might be notes
      if (noteElements.length === 0) {
        noteElements = svg.querySelectorAll('ellipse, circle');
        console.log(`Fallback: Found ${noteElements.length} potential note shapes`);
      }
      
      noteElements.forEach((noteElement, index) => {
        const rect = noteElement.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        
        // Get relative position within SVG
        const x = rect.left - svgRect.left;
        const y = rect.top - svgRect.top;
        
        // Skip if element is too small (likely not a note)
        if (rect.width < 5 || rect.height < 5) return;
        
        // Try to determine note pitch from position
        const noteName = determineNoteFromPosition(y, svg);
        
        notes.push({
          id: `note-${index}`,
          element: noteElement,
          x: x,
          y: y,
          noteName: noteName,
          judged: false,
          highConfidenceSamples: [],
          wrongDetectionTime: null,
          inBufferPeriod: false
        });
      });

      return notes;
    }

    function determineNoteFromPosition(y, svg) {
      // Find staff lines to determine note positions more accurately
      const staffLines = svg.querySelectorAll('line, path');
      const horizontalLines = [];
      
      staffLines.forEach(line => {
        const y1 = parseFloat(line.getAttribute('y1') || line.getAttribute('y') || 0);
        const y2 = parseFloat(line.getAttribute('y2') || line.getAttribute('y') || 0);
        const x1 = parseFloat(line.getAttribute('x1') || line.getAttribute('x') || 0);
        const x2 = parseFloat(line.getAttribute('x2') || line.getAttribute('x') || 0);
        
        // Check if it's a horizontal line (staff line)
        if (Math.abs(y1 - y2) < 2 && Math.abs(x2 - x1) > 50) {
          horizontalLines.push(y1);
        }
      });
      
      // Sort staff lines by Y position
      horizontalLines.sort((a, b) => a - b);
      
      if (horizontalLines.length >= 5) {
        // Use actual staff lines for note detection
        const staffLines = horizontalLines.slice(0, 5); // Take first 5 lines
        const lineSpacing = (staffLines[4] - staffLines[0]) / 4;
        
        // Calculate note position relative to staff
        const relativeToTopLine = y - staffLines[0];
        const linePosition = relativeToTopLine / (lineSpacing / 2);
        
        // Map line positions to notes (treble clef)
        const noteMap = [
          'F6', 'E6', 'D6', 'C6', 'B5', 'A5', 'G5', 'F5', 'E5', 'D5', 'C5', 'B4', 'A4', 'G4', 'F4', 'E4', 'D4', 'C4'
        ];
        
        const noteIndex = Math.round(linePosition);
        if (noteIndex >= 0 && noteIndex < noteMap.length) {
          return noteMap[noteIndex];
        }
      }
      
      // Fallback to simple Y-position mapping
      const svgHeight = svg.getBoundingClientRect().height;
      const staffCenter = svgHeight / 2;
      const relativeY = y - staffCenter;
      
      if (relativeY < -80) return 'A5';
      else if (relativeY < -60) return 'G5';
      else if (relativeY < -40) return 'F5';
      else if (relativeY < -20) return 'E5';
      else if (relativeY < 0) return 'D5';
      else if (relativeY < 20) return 'C5';
      else if (relativeY < 40) return 'B4';
      else if (relativeY < 60) return 'A4';
      else if (relativeY < 80) return 'G4';
      else return 'F4';
    }

    function startNoteRecognitionGame() {
      if (!window.pitchDetector) {
        console.warn('Pitch detector not initialized');
        return;
      }

      gameNotes = extractNotesFromSVG();
      console.log(`Extracted ${gameNotes.length} notes from sheet music`);
      
      isGameRunning = true;
      gameStartTime = Date.now();
      totalPausedTime = 0;
      
      // Start pitch detection loop
      startPitchDetection();
      
      // Start game loop for note judgment
      gameLoop();
    }

    function startPitchDetection() {
      if (detectionInterval) {
        clearInterval(detectionInterval);
      }
      
      detectionInterval = setInterval(() => {
        if (!isPaused && window.pitchDetector && isGameRunning) {
          const pitchData = window.pitchDetector.detectPitch();
          
          if (pitchData && pitchData.confidence > 0.1 && pitchData.volume > 5) {
            const noteInfo = window.pitchDetector.frequencyToNote(pitchData.frequency);
            document.getElementById('current-detected-note').textContent = `${noteInfo.note}${noteInfo.octave}`;
            document.getElementById('current-detected-frequency').textContent = `${pitchData.frequency.toFixed(1)} Hz`;
          } else {
            document.getElementById('current-detected-note').textContent = '-';
            document.getElementById('current-detected-frequency').textContent = '- Hz';
          }
        }
      }, 100);
    }

    function gameLoop() {
      if (!isGameRunning) return;
      
      if (!isPaused) {
        checkNoteJudgments();
      }
      
      requestAnimationFrame(gameLoop);
    }

    function checkNoteJudgments() {
      const currentTime = Date.now();
      const elapsedTime = (currentTime - gameStartTime - totalPausedTime) / 1000;
      const scrollProgress = elapsedTime / animationDuration;
      
      const svg = document.querySelector('#osmd-container svg');
      if (!svg) return;
      
      const svgWidth = svg.getBoundingClientRect().width;
      const totalScrollDistance = svgWidth * 0.8; // 80% as defined in CSS
      const currentScrollX = scrollProgress * totalScrollDistance;
      
      gameNotes.forEach(note => {
        if (note.judged) return;
        
        // Calculate current note position relative to judgment line
        const noteCurrentX = note.x - currentScrollX;
        const distanceToJudgment = Math.abs(noteCurrentX - JUDGMENT_LINE_X);
        
        // Check if note is in judgment zone
        if (distanceToJudgment <= JUDGMENT_TOLERANCE) {
          judgeNote(note);
        }
        // Check if note has passed judgment line (missed)
        else if (noteCurrentX < JUDGMENT_LINE_X - JUDGMENT_TOLERANCE) {
          markNoteMissed(note);
        }
      });
    }

    // Helper function to smooth fluctuating note detections
    function getSmoothedNote(samples, currentTime) {
      if (samples.length === 0) return null;
      
      // Get recent samples for smoothing
      const recentSamples = samples.filter(s => currentTime - s.time <= 150);
      if (recentSamples.length === 0) return null;
      
      // Weight by confidence and recency
      const noteWeights = {};
      recentSamples.forEach(sample => {
        const recencyWeight = 1 - (currentTime - sample.time) / 150;
        const weight = sample.confidence * recencyWeight;
        noteWeights[sample.note] = (noteWeights[sample.note] || 0) + weight;
      });
      
      // Find the note with highest weight
      let maxWeight = 0;
      let bestNote = null;
      let totalWeight = 0;
      
      for (const [note, weight] of Object.entries(noteWeights)) {
        totalWeight += weight;
        if (weight > maxWeight) {
          maxWeight = weight;
          bestNote = note;
        }
      }
      
      const confidence = totalWeight > 0 ? maxWeight / totalWeight : 0;
      return { note: bestNote, confidence, sampleCount: recentSamples.length };
    }

    function judgeNote(note) {
      if (note.judged) return;
      
      const currentTime = Date.now();
      const pitchData = window.pitchDetector.detectPitch();
      const expectedNoteName = note.noteName.replace(/[0-9]/g, ''); // Remove octave number
      
      // Collect samples with lower threshold to catch more detections
      if (pitchData && pitchData.confidence >= 0.4 && pitchData.volume > 5) {
        const detectedNote = window.pitchDetector.frequencyToNote(pitchData.frequency);
        const detectedNoteName = detectedNote.note;
        
        // Add to samples for this specific note
        note.highConfidenceSamples.push({
          note: detectedNoteName,
          confidence: pitchData.confidence,
          time: currentTime,
          cents: Math.abs(detectedNote.cents)
        });
        
        // Keep only samples from the last window
        note.highConfidenceSamples = note.highConfidenceSamples.filter(
          sample => currentTime - sample.time <= 300
        );
        
        // Update global detection history for display purposes
        const isNewNote = !lastDetectedNote || 
                         lastDetectedNote !== detectedNoteName || 
                         (currentTime - lastDetectionTime) > 300;
        
        if (isNewNote) {
          noteDetectionHistory.push({
            note: detectedNoteName,
            time: currentTime,
            confidence: pitchData.confidence
          });
          noteDetectionHistory = noteDetectionHistory.filter(h => currentTime - h.time < 2000);
        }
        
        lastDetectedNote = detectedNoteName;
        lastDetectionTime = currentTime;
      }
      
      // Use smoothed detection with lower requirements
      if (note.highConfidenceSamples.length >= 2) { // Reduced from 3 to 2
        const smoothedResult = getSmoothedNote(note.highConfidenceSamples, currentTime);
        
        if (smoothedResult && smoothedResult.sampleCount >= 2) {
          // Check if the smoothed note matches the expected note
          if (smoothedResult.note === expectedNoteName) {
            // Check for reasonable confidence and pitch accuracy
            const goodSamples = note.highConfidenceSamples
              .filter(s => s.note === expectedNoteName)
              .filter(s => s.confidence > 0.3 && s.cents < 75); // More lenient
            
            if (goodSamples.length >= 1 && smoothedResult.confidence > 0.3) {
              markNoteCorrect(note);
              return;
            }
          } else {
            // Different note detected - start buffer period or mark wrong
            if (!note.wrongDetectionTime && smoothedResult.confidence > 0.5) {
              note.wrongDetectionTime = currentTime;
              note.inBufferPeriod = true;
            } else if (note.wrongDetectionTime && currentTime - note.wrongDetectionTime > 400) {
              if (smoothedResult.confidence > 0.4) {
                markNoteWrong(note, smoothedResult.note);
                return;
              }
            }
          }
        }
      }
      
      // Check if we're in buffer period and should look for recovery
      if (note.inBufferPeriod && note.wrongDetectionTime) {
        // Check if we've detected correct note during buffer period
        const bufferSamples = note.highConfidenceSamples.filter(
          s => s.time >= note.wrongDetectionTime && s.note === expectedNoteName
        );
        
        if (bufferSamples.length >= 1) { // More lenient
          const bufferSmoothed = getSmoothedNote(bufferSamples, currentTime);
          if (bufferSmoothed && bufferSmoothed.note === expectedNoteName && bufferSmoothed.confidence > 0.3) {
            markNoteCorrect(note);
            return;
          }
        }
        
        // If buffer period expired, mark as wrong
        if (currentTime - note.wrongDetectionTime > 400) {
          const wrongSamples = note.highConfidenceSamples.filter(
            s => s.time >= note.wrongDetectionTime && s.note !== expectedNoteName
          );
          
          if (wrongSamples.length > 0) {
            const wrongSmoothed = getSmoothedNote(wrongSamples, currentTime);
            if (wrongSmoothed && wrongSmoothed.confidence > 0.4) {
              markNoteWrong(note, wrongSmoothed.note);
            }
          }
        }
      }
    }

    function getMostFrequentNote(samples) {
      const noteCounts = {};
      samples.forEach(sample => {
        noteCounts[sample.note] = (noteCounts[sample.note] || 0) + 1;
      });
      
      return Object.keys(noteCounts).reduce((a, b) => 
        noteCounts[a] > noteCounts[b] ? a : b
      );
    }

    function markNoteCorrect(note) {
      note.judged = true;
      correctCount++;
      
      // Change note color to green
      const noteheads = note.element.querySelectorAll('path, ellipse, circle');
      noteheads.forEach(notehead => {
        notehead.style.fill = 'green';
        notehead.style.stroke = 'green';
      });
      
      updateScoreDisplay();
    }

    function markNoteWrong(note, detectedNoteName) {
      note.judged = true;
      wrongCount++;
      
      // Change note color to red
      const noteheads = note.element.querySelectorAll('path, ellipse, circle');
      noteheads.forEach(notehead => {
        notehead.style.fill = 'red';
        notehead.style.stroke = 'red';
      });
      
      updateScoreDisplay();
    }

    function markNoteMissed(note) {
      if (note.judged) return;
      
      note.judged = true;
      missedCount++;
      
      // Keep original color but count as missed
      updateScoreDisplay();
    }

    function updateScoreDisplay() {
      document.getElementById('correct-count').textContent = correctCount;
      document.getElementById('missed-count').textContent = missedCount;
      document.getElementById('wrong-count').textContent = wrongCount;
    }

    // Event listeners for controls
    document.getElementById('pause-btn').addEventListener('click', () => {
      if (isPaused) {
        resumeScrolling();
        document.getElementById('pause-btn').textContent = 'Pause';
      } else {
        pauseScrolling();
        document.getElementById('pause-btn').textContent = 'Resume';
      }
    });

    document.getElementById('tempo-slider').addEventListener('input', (e) => {
      const newTempo = parseFloat(e.target.value);
      document.getElementById('tempo-value').textContent = `${newTempo.toFixed(1)}x`;
      setScrollSpeed(newTempo);
    });

    // Initialize in the correct order
    initializeNoteRecognition().then(() => {
      renderMusicXML();
    });

    document.getElementById('music-file-upload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        // Option 1: Create a blob URL (recommended)
        const blobUrl = URL.createObjectURL(file);
        renderMusicXML(blobUrl);
        
        // Clean up the blob URL after use (optional)
        setTimeout(() => URL.revokeObjectURL(blobUrl), 10000);
      }
    });
  </script>
</body>
</html>
